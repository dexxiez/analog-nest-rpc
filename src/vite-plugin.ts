import { createFilter } from "@rollup/pluginutils";
import { glob } from "glob";
import MagicString from "magic-string";
import fs from "node:fs";
import path from "node:path";
import type { Plugin } from "vite";

const SERVER_SUFFIX = "?server";

export interface NestRpcPluginOptions {
  /**
   * Glob pattern to find controller files
   * @default "src/**\/*.controller.ts"
   */
  controllersGlob?: string;

  /**
   * Path where the controller registry will be generated (relative to project root)
   * @default ".analog/nest-controllers.ts"
   */
  registryPath?: string;

  /**
   * Path where Angular injection tokens will be generated (relative to project root)
   * Set to false to disable token generation
   * @default ".analog/inject.ts"
   */
  tokensPath?: string | false;

  /**
   * Import path for the RPC client factory in generated proxies
   * @default "analog-nest-rpc/client"
   */
  clientImport?: string;

  /**
   * Import path for Angular's Injectable decorator
   * @default "@angular/core"
   */
  angularCoreImport?: string;

  /**
   * Enable verbose logging
   * @default false
   */
  debug?: boolean;
}

export const nestRpcPlugin = (options: NestRpcPluginOptions = {}): Plugin => {
  const {
    controllersGlob = "src/**/*.controller.ts",
    registryPath = ".analog/nest-controllers.ts",
    tokensPath = ".analog/inject.ts",
    clientImport = "analog-nest-rpc/client",
    angularCoreImport = "@angular/core",
    debug = false,
  } = options;

  const filter = createFilter(/\.controller\.ts$/);
  const controllerMap = new Map<string, string>(); // Path -> ClassName
  let projectRoot = "";

  const log = (...args: unknown[]) => {
    if (debug) console.log("[nest-rpc]", ...args);
  };

  const scanControllers = () => {
    // Clear existing entries to remove stale controllers (e.g., deleted files)
    controllerMap.clear();

    const controllerFiles = glob.sync(controllersGlob, {
      cwd: projectRoot,
      absolute: true,
    });

    log(`Found ${controllerFiles.length} controller files`);

    for (const filePath of controllerFiles) {
      const code = fs.readFileSync(filePath, "utf-8");
      const classNameMatch = code.match(/class\s+(\w+)/);
      if (classNameMatch) {
        controllerMap.set(filePath, classNameMatch[1]);
        log(
          `  - ${classNameMatch[1]} (${path.relative(projectRoot, filePath)})`,
        );
      }
    }
  };

  const generateRegistryFile = () => {
    const fullRegistryPath = path.join(projectRoot, registryPath);

    const imports = Array.from(controllerMap.entries())
      .map(([filePath, name], idx) => {
        const relativePath = path
          .relative(path.dirname(fullRegistryPath), filePath)
          .replace(/\\/g, "/")
          .replace(/\.ts$/, "");

        return `import { ${name} as Ctl${idx} } from './${relativePath}.js';`;
      })
      .join("\n");

    const exports = Array.from(controllerMap.entries())
      .map(([, name], idx) => `'${name}': Ctl${idx}`)
      .join(",\n  ");

    const content = `// Auto-generated by analog-nest-rpc plugin - DO NOT EDIT
${imports}

export const controllers: Record<string, any> = {
  ${exports}
};
`;

    const dir = path.dirname(fullRegistryPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(fullRegistryPath, content, "utf-8");
    log(`Generated registry at ${registryPath}`);
  };

  const generateTokensFile = () => {
    if (tokensPath === false) return;

    const fullTokensPath = path.join(projectRoot, tokensPath);

    // Generate type imports from each controller file
    const typeImports = Array.from(controllerMap.entries())
      .map(([filePath, name]) => {
        const relativePath = path
          .relative(path.dirname(fullTokensPath), filePath)
          .replace(/\\/g, "/")
          .replace(/\.ts$/, "");

        return `import type { ${name} } from './${relativePath}';`;
      })
      .join("\n");

    // Generate token exports
    const tokenExports = Array.from(controllerMap.entries())
      .map(([, name]) => {
        return `export const ${name} = new InjectionToken<${name}>(
  "${name}",
  {
    providedIn: "root",
    factory: () => createRpcClient<${name}>("${name}"),
  }
);`;
      })
      .join("\n\n");

    const content = `// Auto-generated by analog-nest-rpc plugin - DO NOT EDIT
import { InjectionToken } from "${angularCoreImport}";
import { createRpcClient } from "${clientImport}";

${typeImports}

${tokenExports}
`;

    const dir = path.dirname(fullTokensPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(fullTokensPath, content, "utf-8");
    log(`Generated injection tokens at ${tokensPath}`);
  };

  return {
    name: "vite-plugin-nest-rpc",
    enforce: "pre",

    configResolved(config) {
      projectRoot = config.root;
    },

    buildStart() {
      scanControllers();
      generateRegistryFile();
      generateTokensFile();
    },

    resolveId(id) {
      if (id.endsWith(SERVER_SUFFIX)) {
        const realId = id.slice(0, -SERVER_SUFFIX.length);
        return { id: realId + SERVER_SUFFIX, external: false };
      }
    },

    transform(code, id, transformOptions) {
      // Skip transformation for SSR builds - keep real controllers
      if (transformOptions?.ssr) {
        return;
      }

      // Skip transformation for ?server imports - keep original code
      if (id.endsWith(SERVER_SUFFIX)) {
        return;
      }

      const cleanId = id.split("?")[0];
      if (!filter(cleanId)) return;

      const classNameMatch = code.match(/class\s+(\w+)/);
      if (!classNameMatch) return;
      const className = classNameMatch[1];

      // Update registry and tokens
      controllerMap.set(cleanId, className);
      generateRegistryFile();
      generateTokensFile();

      log(`Transforming ${className} to RPC proxy`);

      const ms = new MagicString(code);
      const proxyCode = `
import { Injectable } from '${angularCoreImport}';
import { createRpcClient } from '${clientImport}';

@Injectable()
export class ${className} {
  constructor() {
    return createRpcClient('${className}');
  }
}
`;

      ms.overwrite(0, code.length, proxyCode);

      return {
        code: ms.toString(),
        map: ms.generateMap({ hires: true }),
      };
    },

    handleHotUpdate({ file }) {
      const cleanFile = file.split("?")[0];

      // Early exit for non-controller files
      if (!filter(cleanFile)) return;

      // Check if a controller file was deleted or renamed
      if (!fs.existsSync(cleanFile)) {
        // File was deleted - remove from map and regenerate
        log(
          `Controller file deleted: ${path.relative(projectRoot, cleanFile)}`,
        );
        controllerMap.delete(cleanFile);
        generateRegistryFile();
        generateTokensFile();
      }
    },
  };
};

export default nestRpcPlugin;
